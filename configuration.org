#+TITLE: Emacs Configuration
#+AUTHOR: Jade Lin
#+EMAIL: linw1995@icloud.com

* Package Managing

Bootstrapping [[https://github.com/raxod502/straight.el][straight.el]].

#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

Integration with [[https://github.com/jwiegley/use-package][use-package]].

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'use-package)
#+END_SRC

* Editor Configuration

Change cursor type.
#+BEGIN_SRC emacs-lisp
  (setq-default cursor-type 'bar)
#+END_SRC

Show line number.
#+BEGIN_SRC emacs-lisp
  (global-linum-mode 1)
#+END_SRC

Don't create backup files.
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

Delete selection while inserting.
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

Highlight line where cursor lying on.
#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode 1)
#+END_SRC

Wrap lines at word boundary.
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode 1)
#+END_SRC

Multi-cursors support.
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :straight t)
#+END_SRC

* Key Binding Configuration

*** iTerm Integration

For avoiding unexpected behavior of key bindings,
due to the terminal sends incomplete key events,
we need to configure iTerm key bindings to send escape sequence codes,
and, the Emacs should parse escape sequence codes sent from iTerm and should emit the actual key events.
See [[https://stackoverflow.com/a/40222318/7035932][Stackoverflow Answer]] for more details.

#+BEGIN_SRC emacs-lisp
  (defun my/global-map-and-set-key (key command &optional prefix suffix)
     "`my/map-key' KEY then `global-set-key' KEY with COMMAND.
   PREFIX or SUFFIX can wrap the key when passing to `global-set-key'."
     (my/map-key key)
     (global-set-key (kbd (concat prefix key suffix)) command))

  (defun my/map-key (key)
     "Map KEY from escape sequence \"\e[emacs-KEY\."
     (define-key function-key-map (concat "\e[emacs-" key) (kbd key)))

#+END_SRC

*** Toggle Visibility of Shell Buffer

#+BEGIN_SRC emacs-lisp
  (my/global-map-and-set-key "C-\`" 'toggle-shell-splited-window)
  (my/global-map-and-set-key "C-s-\`" 'toggle-shell)
#+END_SRC

* Shell Configuration

Ensure environment variables inside Emacs look the same as in the user's shell.
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :straight t
    :if (memq window-system '(mac ns))
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

Create =toggle-shell= command to toggle visibility of shell buffer.

#+BEGIN_SRC emacs-lisp
  ; Get shell executable path from environment variables.
  (setq explicit-shell-file-name (getenv "SHELL"))

  (defvar toggle-shell--shell-buffer nil)
  (defvar toggle-shell--shell-splited-window nil)
  (defvar toggle-shell--previous-window-configuration nil)

  (defun toggle-shell--dump-window-configuration ()
    (setq toggle-shell--previous-window-configuration
	  (current-window-configuration)))

  (defun toggle-shell--restore-window-configuration ()
    (set-window-configuration toggle-shell--previous-window-configuration))

  (defun toggle-shell--in-shell-splited-window? ()
    "Test current buffer is shell buffer and is in splited window."
    (and (toggle-shell--in-shell?)
	 toggle-shell--shell-splited-window
	 (equal (selected-window) toggle-shell--shell-splited-window) ; test selected window is splited window
	 ))

  (defun toggle-shell--in-shell? ()
    "Test current buffer is shell buffer."
    (and toggle-shell--shell-buffer ; test var of shell buffer is not nil
	 (equal (current-buffer) toggle-shell--shell-buffer)) ; test current buffer is shell buffer
    )

  (defun toggle-shell--shell-buffer-existed? ()
    "Test shell buffer existed."
    (and toggle-shell--shell-buffer ; test shell buffer is not nill
	 (buffer-name toggle-shell--shell-buffer)) ; test shell buffer is not killed
    )

  (defun toggle-shell--ensure-shell-buffer ()
    "Ensure the shell buffer existed."
    (unless (toggle-shell--shell-buffer-existed?)
      (toggle-shell--dump-window-configuration)
      (setq toggle-shell--shell-buffer (ansi-term explicit-shell-file-name)) ; create new shell buffer
      (toggle-shell--restore-window-configuration)))

  (defun toggle-shell--switch-to-shell ()
    "Make shell buffer current."
    (when (toggle-shell--in-shell-splited-window?)
      (toggle-shell--restore-window-configuration))
    (unless (toggle-shell--in-shell?)
      (toggle-shell--ensure-shell-buffer)
      (toggle-shell--dump-window-configuration)
      (switch-to-buffer toggle-shell--shell-buffer)))

  (defun toggle-shell--delete-shell ()
    "Delete the shell buffer window"
    (when (toggle-shell--shell-buffer-existed?)
      (let ((window) (get-buffer-window toggle-shell--shell-buffer))
	(if window
	    (delete-window window)
	  (toggle-shell--restore-window-configuration)))))

  (defun toggle-shell--delete-shell-splited-window ()
    "Delete the shell buffer splited window"
    (when (toggle-shell--in-shell-splited-window?)
      (delete-window toggle-shell--shell-splited-window)))

  (defun toggle-shell--switch-to-shell-splited-window ()
    "Split the current window set the bottom one as shell."
    (unless (toggle-shell--in-shell-splited-window?)
      (when (toggle-shell--in-shell?)
	(toggle-shell--restore-window-configuration))
      (toggle-shell--ensure-shell-buffer)
      (toggle-shell--dump-window-configuration)
      (split-window)
      (setq toggle-shell--shell-splited-window (window-next-sibling))
      (set-window-buffer (window-next-sibling)
			 toggle-shell--shell-buffer)
      (select-window (window-next-sibling))))

  (defun toggle-shell ()
    "Toggle visibility of shell buffer.
  1) If in shell buffer and in full window, switch to previous buffer.
  2) If in shell buffer and in splited window, switch to full window.
  3) If in other buffer, switch to shell buffer in full window."
    (interactive)
    (cond ((toggle-shell--in-shell-splited-window?) (toggle-shell--switch-to-shell))
	  ((toggle-shell--in-shell?) (toggle-shell--delete-shell))
	  (t (toggle-shell--switch-to-shell))))

  (defun toggle-shell-splited-window ()
    "Toggle visibility of shell buffer window and focused.
  1) If in other buffer, switch to shell buffer in half window.
  2) If in shell buffer and in full window, switch to half window.
  3) If in shell buffer and in splited window, delete the shell buffer window."
    (interactive)
    (cond ((toggle-shell--in-shell-splited-window?) (toggle-shell--delete-shell-splited-window))
	  (t (toggle-shell--switch-to-shell-splited-window))))
#+END_SRC

* Appearance Configuration
** Theme Configuration

Use [[https://github.com/hlissner/emacs-doom-themes][DOOM Themes]].
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :straight t
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
	  doom-themes-enable-italic t) ; if nil, italics is universally disabled
    (load-theme 'doom-one t)
    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)
    ;; Enable custom neotree theme (all-the-icons must be installed!)
    (doom-themes-neotree-config)
    ;; or for treemacs users
    (setq doom-themes-treemacs-theme "doom-colors") ; use the colorful treemacs theme
    (doom-themes-treemacs-config)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+END_SRC

** GUI Configuration
*** Common
Disable dialog box.
#+BEGIN_SRC emacs-lisp
  (setq use-file-dialog        nil
	use-dialog-box         nil)
#+END_SRC

Hide toolbar.
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
#+END_SRC

Hide scrollbar.
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'set-scroll-bar-mode)
    (set-scroll-bar-mode nil))
#+END_SRC

*** MacOS

Make the title bar and toolbar to be transparent.
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (add-to-list 'default-frame-alist
		 '(ns-transparent-titlebar . t))
    (add-to-list 'default-frame-alist
		 '(ns-appearance . dark)))
#+END_SRC

Change the opacity of the frame.
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (add-to-list 'default-frame-alist
		 '(alpha . (100 . 100))))
#+END_SRC

** Dashboard

#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :straight t
    :config
    (dashboard-setup-startup-hook))
#+END_SRC

Hide the original startup screen while opening file.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
#+END_SRC

** Icons

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :straight t)
#+END_SRC

** Directory Tree View

Use [[https://github.com/jaypei/emacs-neotree][neotree]] package.

#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :straight t
    :bind ("<f8>" . neotree-toggle))
#+END_SRC

** Rainbow Delimiters

Use [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] to highlights delimiters such as parentheses, brackets or braces according to their depth.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :straight t
    :hook ((emacs-lisp-mode . rainbow-delimiters-mode)
	   (racket-mode . rainbow-delimiters-mode)
	   (racket-repl-mode . rainbow-delimiters-mode)))
#+END_SRC	 

* Project Managing Configuration

Use [[https://docs.projectile.mx/projectile/index.html][projectile]] package.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :straight t
    :bind-keymap ("C-c p" . projectile-command-map)
    :config
    (projectile-mode +1)
    (setq projectile-switch-project-action 'neotree-projectile-action))
#+END_SRC

* Productivity Tools
** Completion Tools

Use [[https://github.com/abo-abo/swiper#ivy][Ivy]] pacakge for minibuffer completion. <<Counsel Configuration>>

*** Replace isearch with swiper

Configure =<C-s>= and =<C-r>= to activate swiper. And =swiper-C-r= function, which bind with =<C-r>= in local keymaps =swiper-map=, is copyed from [[https://github.com/abo-abo/swiper/issues/1172#issuecomment-633148859][Issue's comment commented by SreenivasVRao from abo-abo/swiper#1172]].

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :straight t
    :config
    (setq ivy-use-virtual-buffers t)
    (setq enable-recursive-minibuffers t)
    (setq ivy-count-format "(%d/%d) ")
    (ivy-mode 1))
  (use-package counsel
    :straight t
    :after ivy
    :bind ("M-x" . 'counsel-M-x))
  (use-package swiper
    :straight t
    :after ivy
    :config
    (defun swiper-C-r (&optional arg)
      "Move cursor vertically down ARG candidates. If the input is empty, select the previous history element instead."
      (interactive "p")
      (if (string= ivy-text "")
	  (ivy-previous-history-element 1)
	(ivy-previous-line arg)))
    :bind (("C-s" . 'swiper)
	   ("C-r" . 'swiper)
	   :map swiper-map
	   ("C-r" . 'swiper-C-r)))
#+END_SRC

Use [[http://company-mode.github.io/][company-mode]] for text completion.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :straight t
    :config
    (setq company-minimum-prefix-length 2)
    (setq company-idle-delay 0.1)
    (setq company-tooltip-align-annotations t)
    :hook ((emacs-lisp-mode . company-mode)
	   (racket-mode . company-mode)
	   (racket-repl-mode . company-mode)))
#+END_SRC

** Editing Tools

Use the built-in version of Org.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :straight (:type built-in))
#+END_SRC

Paredit is a minor mode for performing structured editing of S-expression data.
Paredit helps keep parentheses balanced and adds many keys for moving S-expressions and moving around in S-expressions. See [[http://danmidwood.com/content/2014/11/21/animated-paredit.html][The Animated Guide to Paredit]] for more details.

Using =define-paredit-pair= macro to define full-width round, square and curly pairs, will generate some helpfull functions. And bind their opening and closing functions into local keymaps =paredit-mode-map=.

#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :straight t
    :hook ((emacs-lisp-mode . paredit-mode)
	   (racket-mode . paredit-mode)
	   (racket-repl-mode . paredit-mode))
    :config
    (define-paredit-pair ?\（ ?\） "full-round")
    (define-paredit-pair ?\【 ?\】 "full-square")
    (define-paredit-pair ?\「 ?\」 "full-curly")
    :bind (:map paredit-mode-map
		("（" . 'paredit-open-full-round)
		("）" . 'paredit-close-full-round)
		("【" . 'paredit-open-full-square)
		("】" . 'paredit-close-full-square)
		("「" . 'paredit-open-full-curly)
		("」" . 'paredit-close-full-curly)))
#+END_SRC

** Version Control Tools

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :straight t
    :config
    (global-set-key (kbd "C-x g") 'magit-status))
#+END_SRC

** GTD

#+BEGIN_SRC emacs-lisp
  (use-package org-journal
    :straight t
    :config
    (setq org-journal-dir "~/Documents/me/log")
    (setq org-journal-enable-agenda-integration t))
#+END_SRC

* Programing Configuration
** Racket

#+BEGIN_SRC emacs-lisp
  (use-package racket-mode
    :straight t
    :hook (racket-mode . racket-xp-mode))
#+END_SRC

** Org

#+BEGIN_SRC emacs-lisp
  (use-package ob-racket
    :straight
    (:host github :repo "hasu/emacs-ob-racket")
    :config
    (org-babel-do-load-languages 'org-babel-load-languages
				 '((racket . t))))

  (defun org-mode-configuration ()
    (setq org-adapt-indentation nil)
    (setq org-catch-invisible-edits 'smart))
  (add-hook 'org-mode-hook 'org-mode-configuration)
#+END_SRC

Use htmlize to support exporting code with syntax highlighting.

#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :straight t)
#+END_SRC    

Configure =org-goto= with counsel. [[https://emacs.stackexchange.com/a/32625/29268][Solution is copyed from stackoverflow.]]
See also [[Counsel Configuration]].

#+BEGIN_SRC emacs-lisp
  (defun org-goto-configuration ()
    (setq org-goto-interface 'outline-path-completion)
    (setq org-outline-path-complete-in-steps nil))
  (add-hook 'org-mode-hook 'org-goto-configuration)
#+END_SRC
* Misc
** MacOS

Dired is a directory editor on Emacs. It uses =ls= program.
On macOS, ls does not support =--dired= option.
Appending below codes into =.emacs= file to configure dired using =ls= without =--dired=.
#+BEGIN_SRC emacs-lisp
  (when (string= system-type "darwin")
    (setq dired-use-ls-dired nil))
#+END_SRC
